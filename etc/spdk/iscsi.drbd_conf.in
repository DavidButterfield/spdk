# etc/spdk/iscsi.drbd_conf.in
# iSCSI target configuration file using DRBD and tcmu-runner storage handlers

[Global]
  #SharedMemoryID 0
  #NoPci Yes
  #TpointGroupMask 0x0

[Bdev]
  #BdevIoPoolSize 65536
  #BdevIoCacheSize 256

#XXX NOTE: Only handler_ram.so and handler_file.so have been tested so far.
#XXX       Need to try an async handler (nr_threads == 0)!

# Format for tcmu-runner handler devices:
#	TCMUR <tcmur-minor-number> <dev-name> <tcmur-cfg-str>
# tcmur-minor-number should be less than 256 and unique across TCMUR instances.
# dev-name is arbitrary but should be unique across instances.
# tcmu-runner handler name is derived from the first segment of tcmur-cfg-str.
[TCMUR]

# Originally there was a mix of handler_ram and handler_file devices in the
# example configuration; but handler_file performs significantly better, so by
# default it is used to back all the devices now.  (But the device names and
# filenames in /tmp are left as they were, to continue to match the diagram.)
  TCMUR 0 ram_a  /file//tmp/tcmur_ram00
  TCMUR 1 file_a /file//tmp/tcmur_file00
  TCMUR 2 file_b /file//tmp/tcmur_file01
  TCMUR 3 ram_b  /file//tmp/tcmur_ram01
# TCMUR 4 file_c /file//tmp/tcmur_file02
# TCMUR 5 ram_c  /file//tmp/tcmur_ram02

#XXX There was some problem using handler_file where the symbols in its ops
#    vector ("file_handler") get UNrelocated apparently at random, leading to
#    segmentation violation on attempt to call the un-relocated address.  This
#    occurs after many successful calls through the ops vector, which was
#    observed under GDB after it was properly relocated and before it was later
#    observed to be un-relocated.
#
#    However this problem has disappeared now that I am running the initiator
#    remotely and otherwise being more careful about memory usage.  My SPDK
#    machine has only 4GiB of RAM, and it was consuming swap space when I saw
#    this problem.  I believe I have only ever seen this "unrelocate the
#    symbols" trick under heavy memory pressure.
#
#    It seems as though the page were stolen to be used at some other virtual
#    address, and then later demand-paged back in, but with the original,
#    unrelocated contents from the executable file.
#
# Use handler_ram
# TCMUR 0 ram_a  /ram/tmp/tcmur_ram00
# TCMUR 1 file_a /ram/tmp/tcmur_file00
# TCMUR 2 file_b /ram/tmp/tcmur_file01
# TCMUR 3 ram_b  /ram/tmp/tcmur_ram01
## TCMUR 4 file_c /ram/tmp/tcmur_file02
## TCMUR 5 ram_c  /ram/tmp/tcmur_ram02

# From DRBD native configuration
#   volume 0 {
#       device      drbd2 minor 2;
#       disk        "/UMCfuse/dev/ram_b";
#   }
#
#   volume 0 {
#       device      drbd1 minor 1;
#       disk        "/UMCfuse/dev/file_c";
#   }

# Translate from SPDK BDEV protocol to kernel BIO protocol
# (SPDK front-end shim for kernel BIO modules)
# Format:
# BIO <spdk-bdev-name> <bio-dev-name> [ helper [ arg1 [ arg2 ] ] ]
[BIO]
  BIO bio0 /UMCfuse/dev/file_b
  BIO bio1 /UMCfuse/dev/drbd2 drbdadm_up_primary spdk /UMCfuse/dev/ram_b

[Malloc]
  NumberOfLuns 1
  LunSizeInMB 128
  BlockSize 4096

[AIO]
  AIO /tmp/myfile AIO0 4096

[iSCSI]
  NodeBase "iqn.2016-06.io.spdk"
  AuthFile /usr/local/etc/spdk/auth.conf
  Timeout 30
  DiscoveryAuthMethod Auto
  #MaxSessions 128
  #MaxConnectionsPerSession 2
  DefaultTime2Wait 2
  DefaultTime2Retain 60
  FirstBurstLength 8192
  ImmediateData Yes
  ErrorRecoveryLevel 0

[PortalGroup1]
  Portal DA1 192.168.1.23:3260

[InitiatorGroup1]
  InitiatorName ANY
  Netmask 192.168.1.0/24

[TargetNode1]
  TargetName disk1
  TargetAlias "Data Disk1"
  Mapping PortalGroup1 InitiatorGroup1
  AuthMethod Auto
  AuthGroup AuthGroup1
  UseDigest Auto
  QueueDepth 64
  LUN0 Malloc0
  LUN1 AIO0
  LUN2 ram_a
  LUN3 file_a
  LUN4 bio0
  LUN5 bio1
